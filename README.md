![Algorithm Demonstration][assets/example-performance.gif]
# Description
This Rust program displays a GUI with several plots, allowing the user to visualize the evolution of a genetic algorithm (GA), which has been configured to design a full-state feedback controller for an inverted pendulum on a cart. The system dynamics allow a single control input, which is a force on the cart that will accelerate/decelerate the cart. This dynamical system is characterized by four state variables: position (x), velocity (x_dot), pendulum angle (theta), and pendulum angular velocity (theta_dot). The control objective is to translate the system from a position of -1 [m] and angle of 3.15 [rad] to a position of 1 [m] and 3.14 [rad].This means the system starts slightly off balance and it must translate it 2 [m] in the positive direction, balancing the pendulum about the vertical equilibrium position. This program runs a physics simulation under the hood to evaluate how well the different controllers achieve the control objective. 

All model and simulation parameters are configurable from the GUI, allowing the user to simulate (1) different versions of the system dynamics, (2) different initial conditions and target states, (3) different durations of the physics simulation, and (4) different GA algorithm parameters like stochasticity, search space, elitism, number of generations. You can even alter these parameters as the GA is running, allowing you to tune the algorithm in real-time. This highly interactive interface makes it intuitive to understand how the different parameters alter the GA performance.

All the plots update in real-time as the algorithm evolves over the generations. To benchmark the GA performance, I compare the performance of the best controller designed by the GA to a linear quadratic regulator (LQR), which is the optimal controller obtained by linearizing the dynamics about the desired fixed point. To benchmark individuals within a population for the GA, I implemented a cost function which calculates how close each individual's trajectoryis is to the target trajectory. There are more details below in the method section.

There is a cost plot, which displays the best GA cost compared to the LQR cost. There are also two plots of the full parameter space, showing how the GA converges to high performance regions of the parameter space. Interestingly, you can watch the algorithm cluster over time to areas of parameter space close to the LQR solution. This indicates that the GA is approaching a local optimum of the parameter space (i.e. optimal with respect to the cost function).

# Motivation
There are several motivations for this project. Firstly, I created this project because I wanted to learn more about Rust in general, but also how to work with the language's GUI libraries to do computing and analysis for the other things I care about (e.g. robotics, controls, machine learning, and math modeling). Already knowing C++, Python, MATLAB, and Simulink (among others), Rust seemed to be a natural next step in this respect. Secondly, I wanted to produce a high-performance rewrite of this project that I could maintain and extend in the future. I implemented this a few years ago in Python/Cython on my old computer â€” and was not only unhappy with the performance, but the code no longer runs on my new machine. Thirdly, while this is not necessarly a great way to design a controller for this particular system, this is a really interesting framework for designing anything that you can simulate. For example, if you have a physics-informed neural network standing in for a dynamics model, you could use a computational approach like a genetic algorithm to design a controller. Or if you have stress modeling on a mechanical component or a fluid simulation on a vehicle, you could imagine having a genetic algorithm exploring the parameter space to help design those systems.

# Method Details
For the GUI, I used egui_plot (https://github.com/emilk/egui_plot/tree/main). Both the UI and the GA simulation run on a single thread, as the physics calculations are lightweight enough that the simulation doesn't really block the UI.

The genetic algorithm evaluates each individual (i.e. a controller) in the population according to their "fitness". This evolutionary fitness metric is calculated by simulating the system dynamics with a given controller and evaluating them with a cost function. According to the cost of each individual in the population, you can rank the individuals and use this to constuct a weighted probability distribution, from which you can determine which individuals will advance to the next generation. For constructing the next generation, there are two methods by which an individual can enter into the next generation. Firstly, there is eltism, allowing an arbitrary number of individuals to directly advance to the next generation without being altered. Secondly, for the remaining slots in the population, parents are randomly selected to reproduce from the existing population according to the weighted distribution, from which "offspring" are calculated by numerically averaging them and injecting some noise. This noise is controlled by the 'stochasticity' parameter in the GA configuration section of the GUI. This genetic selection, crossover, and mutation is what allows the algorithm to explore new areas of the search space.

For the dynamics simulation, I implemented a 4th order Runge Kutta integrator (RK4) scheme (more here: https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods).

For the cost function, I calculate the integral of absolute state error across all state variables for the entire duration of the trajectory. This integral is weighted by a weighting vector, similar to an LQR approach where you can penalize each state variable independently in the state cost matrix.

