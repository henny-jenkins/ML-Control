# Description
This Rust program displays a GUI with several plots, allowing the user to visualize the evolution of a genetic algorithm (GA), which has been configured to design a full-state feedback controller for an inverted pendulum on a cart. The system dynamics allow a single control input, which is a force on the cart that will accelerate/decelerate the cart. This dynamical system is characterized by four state variables: position (x), velocity (x_dot), pendulum angle (theta), and pendulum angular velocity (theta_dot). The control objective is to translate the system from a position of -1 [m] and angle of 3.15 [rad] to a position of 1 [m] and 3.14 [rad].This means the system starts slightly off balance and it must translate it 2 [m] in the positive direction, balancing the pendulum about the vertical equilibrium position. This program runs a physics simulation under the hood to evaluate how well the different controllers achieve the control objective. 

All model and simulation parameters are configurable from the GUI, allowing the user to simulate (1) different versions of the system dynamics, (2) different initial conditions and target states, (3) different durations of the physics simulation, and (4) different GA algorithm parameters like stochasticity, search space, elitism, number of generations. You can even alter these parameters as the GA is running, allowing you to tune the algorithm in real-time. This highly interactive interface makes it intuitive to understand how the different parameters alter the GA performance.

All the plots update in real-time as the algorithm evolves over the generations. To benchmark the GA performance, I compare the performance of the best controller designed by the GA to a linear quadratic regulator (LQR), which is the optimal controller obtained by linearizing the dynamics about the desired fixed point. To benchmark individuals within a population for the GA, I implemented a cost function which calculates the integral of absolute state error across all the state variables, weighted by a weighting vector.

There is a cost plot, which displays the best GA cost compared to the LQR cost. There are also two plots of the full parameter space, showing how the GA converges to high performance regions of the parameter space. Interestingly, you can watch the algorithm cluster over time to areas of parameter space close to the LQR solution. This indicates that the GA is approaching a local optimum of the parameter space (i.e. optimal with respect to the cost function).

# Motivation
There are several motivations for this project. Firstly, I created this project because I wanted to learn more about Rust in general, but also how to work with the language's GUI libraries to do computing and analysis for the other things I care about (e.g. robotics, controls, machine learning, and math modeling). Already knowing C++, Python, MATLAB, and Simulink (among others), Rust seemed to be a natural next step in this respect. Secondly, I wanted to produce a high-performance rewrite of this project that I could maintain and extend in the future. I implemented this a few years ago in Python/Cython on my old computer â€” and was not only unhappy with the performance, but the code no longer runs on my new machine. Thirdly, while this is not necessarly a great way to design a controller for this particular system, this is a really interesting framework for designing anything that you can simulate. For example, if you have a physics-informed neural network standing in for a dynamics model, you could use a computational approach like a genetic algorithm to design a controller. Or if you have stress modeling on a mechanical component or a fluid simulation on a vehicle, you could imagine having a genetic algorithm exploring the parameter space to help design those systems.

# Method Details
